import{s as A}from"./multihashes.7f388a2b.js";import{r as U}from"./err-code.3bb72d65.js";import{a as S}from"./js-sha3.012d80df.js";import{m as H}from"./murmurhash3js-revisited.33d666f6.js";import{c as _,b as $}from"./uint8arrays.2e5a3914.js";import{r as g}from"./blakejs.877f422c.js";const T=A,o=self.crypto||self.msCrypto,y=async(r,e)=>{if(typeof self>"u"||!o)throw new Error("Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context");switch(e){case"sha1":return new Uint8Array(await o.subtle.digest({name:"SHA-1"},r));case"sha2-256":return new Uint8Array(await o.subtle.digest({name:"SHA-256"},r));case"sha2-512":return new Uint8Array(await o.subtle.digest({name:"SHA-512"},r));case"dbl-sha2-256":{const a=await o.subtle.digest({name:"SHA-256"},r);return new Uint8Array(await o.subtle.digest({name:"SHA-256"},a))}default:throw new Error(`${e} is not a supported algorithm`)}};var E={factory:r=>async e=>y(e,r),digest:y,multihashing:async(r,e,a)=>{const u=await y(r,e);return T.encode(u,e,a)}};const v=r=>{const e=new Uint8Array(4);for(let a=0;a<4;a++)e[a]=r&255,r=r>>8;return e};var R={fromNumberTo32BitBuf:v},l,b;function q(){if(b)return l;b=1;const r=g(),e=45569,a=45633,u={init:r.blake2bInit,update:r.blake2bUpdate,digest:r.blake2bFinal},h={init:r.blake2sInit,update:r.blake2sUpdate,digest:r.blake2sFinal},w=(k,t)=>async B=>{const d=t.init(k,null);return t.update(d,B),t.digest(d)};return l=k=>{for(let t=0;t<64;t++)k[e+t]=w(t+1,u);for(let t=0;t<32;t++)k[a+t]=w(t+1,h)},l}const i=S.exports,p=H.exports,{factory:f}=E,{fromNumberTo32BitBuf:C}=R,{fromString:I}=_,n=r=>async e=>{switch(r){case"sha3-224":return new Uint8Array(i.sha3_224.arrayBuffer(e));case"sha3-256":return new Uint8Array(i.sha3_256.arrayBuffer(e));case"sha3-384":return new Uint8Array(i.sha3_384.arrayBuffer(e));case"sha3-512":return new Uint8Array(i.sha3_512.arrayBuffer(e));case"shake-128":return new Uint8Array(i.shake128.create(128).update(e).arrayBuffer());case"shake-256":return new Uint8Array(i.shake256.create(256).update(e).arrayBuffer());case"keccak-224":return new Uint8Array(i.keccak224.arrayBuffer(e));case"keccak-256":return new Uint8Array(i.keccak256.arrayBuffer(e));case"keccak-384":return new Uint8Array(i.keccak384.arrayBuffer(e));case"keccak-512":return new Uint8Array(i.keccak512.arrayBuffer(e));case"murmur3-128":return I(p.x64.hash128(e),"base16");case"murmur3-32":return C(p.x86.hash32(e));default:throw new TypeError(`${r} is not a supported algorithm`)}},N=r=>r;var O={identity:N,sha1:f("sha1"),sha2256:f("sha2-256"),sha2512:f("sha2-512"),dblSha2256:f("dbl-sha2-256"),sha3224:n("sha3-224"),sha3256:n("sha3-256"),sha3384:n("sha3-384"),sha3512:n("sha3-512"),shake128:n("shake-128"),shake256:n("shake-256"),keccak224:n("keccak-224"),keccak256:n("keccak-256"),keccak384:n("keccak-384"),keccak512:n("keccak-512"),murmur3128:n("murmur3-128"),murmur332:n("murmur3-32"),addBlake:q()};const x=U(),m=A,s=O,{equals:P}=$;async function c(r,e,a){const u=await c.digest(r,e,a);return m.encode(u,e,a)}c.multihash=m;c.digest=async(r,e,a)=>{const h=await c.createHash(e)(r);return a?h.slice(0,a):h};c.createHash=function(r){if(!r)throw x(new Error("hash algorithm must be specified"),"ERR_HASH_ALGORITHM_NOT_SPECIFIED");const e=m.coerceCode(r);if(!c.functions[e])throw x(new Error(`multihash function '${r}' not yet supported`),"ERR_HASH_ALGORITHM_NOT_SUPPORTED");return c.functions[e]};c.functions={0:s.identity,17:s.sha1,18:s.sha2256,19:s.sha2512,20:s.sha3512,21:s.sha3384,22:s.sha3256,23:s.sha3224,24:s.shake128,25:s.shake256,26:s.keccak224,27:s.keccak256,28:s.keccak384,29:s.keccak512,34:s.murmur3128,35:s.murmur332,86:s.dblSha2256};s.addBlake(c.functions);c.validate=async(r,e)=>{const a=await c(r,m.decode(e).name);return P(e,a)};var z=c;export{z as s};
