import{r as P}from"./sparse-array.0ed1ce17.js";import{c as k,r as m}from"./uint8arrays.2e5a3914.js";var d,B;function C(){if(B)return d;B=1;const c=P(),{fromString:l}=k;class a{constructor(e,t,i=0){this._options=e,this._popCount=0,this._parent=t,this._posAtParent=i,this._children=new c,this.key=null}async put(e,t){const i=await this._findNewBucketAndPos(e);await i.bucket._putAt(i,e,t)}async get(e){const t=await this._findChild(e);if(t)return t.value}async del(e){const t=await this._findPlace(e),i=t.bucket._at(t.pos);i&&i.key===e&&t.bucket._delAt(t.pos)}leafCount(){return this._children.compactArray().reduce((t,i)=>i instanceof a?t+i.leafCount():t+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const e=this._children.compactArray();for(const t of e)t instanceof a?yield*t.eachLeafSeries():yield t;return[]}serialize(e,t){const i=[];return t(this._children.reduce((h,f,A)=>(f&&(f instanceof a?h.push(f.serialize(e,t)):h.push(e(f,A))),h),i))}asyncTransform(e,t){return s(this,e,t)}toJSON(){return this.serialize(u,r)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(e){const t=await this._findPlace(e),i=t.bucket._at(t.pos);if(!(i instanceof a)&&i&&i.key===e)return i}async _findPlace(e){const t=this._options.hash(typeof e=="string"?l(e):e),i=await t.take(this._options.bits),h=this._children.get(i);return h instanceof a?h._findPlace(t):{bucket:this,pos:i,hash:t,existingChild:h}}async _findNewBucketAndPos(e){const t=await this._findPlace(e);if(t.existingChild&&t.existingChild.key!==e){const i=new a(this._options,t.bucket,t.pos);t.bucket._putObjectAt(t.pos,i);const h=await i._findPlace(t.existingChild.hash);return h.bucket._putAt(h,t.existingChild.key,t.existingChild.value),i._findNewBucketAndPos(t.hash)}return t}_putAt(e,t,i){this._putObjectAt(e.pos,{key:t,value:i,hash:e.hash})}_putObjectAt(e,t){this._children.get(e)||this._popCount++,this._children.set(e,t)}_delAt(e){if(e===-1)throw new Error("Invalid position");this._children.get(e)&&this._popCount--,this._children.unset(e),this._level()}_level(){if(this._parent&&this._popCount<=1)if(this._popCount===1){const e=this._children.find(o);if(e&&!(e instanceof a)){const t=e.hash;t.untake(this._options.bits);const i={pos:this._posAtParent,hash:t,bucket:this._parent};this._parent._putAt(i,e.key,e.value)}}else this._parent._delAt(this._posAtParent)}_at(e){return this._children.get(e)}}function o(n){return Boolean(n)}function u(n,e){return n.key}function r(n){return n}async function s(n,e,t){const i=[];for(const h of n._children.compactArray())if(h instanceof a)await s(h,e,t);else{const f=await e(h);i.push({bitField:n._children.bitField(),children:f})}return t(i)}return d=a,d}var _={exports:{}},p,y;function g(){if(y)return p;y=1;const c=[255,254,252,248,240,224,192,128],l=[1,3,7,15,31,63,127,255];p=class{constructor(r){this._value=r,this._currentBytePos=r.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(r){let s=r,n=0;for(;s&&this._haveBits();){const e=this._value[this._currentBytePos],t=this._currentBitPos+1,i=Math.min(t,s),h=a(e,t-i,i);n=(n<<i)+h,s-=i,this._currentBitPos-=i,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return n}untake(r){for(this._currentBitPos+=r;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function a(u,r,s){const n=o(r,s);return(u&n)>>>r}function o(u,r){return c[u]&l[Math.min(r+u-1,7)]}return p}var v;function x(){if(v)return _.exports;v=1;const c=g(),{concat:l}=m;function a(u){function r(s){return s instanceof o?s:new o(s,u)}return r}class o{constructor(r,s){if(!(r instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=r,this._hashFn=s,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(r){let s=r;for(;this._availableBits<s;)await this._produceMoreBits();let n=0;for(;s>0;){const e=this._buffers[this._currentBufferIndex],t=Math.min(e.availableBits(),s),i=e.take(t);n=(n<<t)+i,s-=t,this._availableBits-=t,e.availableBits()===0&&this._currentBufferIndex++}return n}untake(r){let s=r;for(;s>0;){const n=this._buffers[this._currentBufferIndex],e=Math.min(n.totalBits()-n.availableBits(),s);n.untake(e),s-=e,this._availableBits+=e,this._currentBufferIndex>0&&n.totalBits()===n.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const r=this._depth?l([this._value,Uint8Array.from([this._depth])]):this._value,s=await this._hashFn(r),n=new c(s);this._buffers.push(n),this._availableBits+=n.availableBits()}}return _.exports=a,_.exports.InfiniteHash=o,_.exports}var b,w;function I(){if(w)return b;w=1;const c=C(),l=x();function a(o){if(!o||!o.hashFn)throw new Error("please define an options.hashFn");const u={bits:o.bits||8,hash:l(o.hashFn)};return new c(u)}return b={createHAMT:a,Bucket:c},b}export{I as r};
