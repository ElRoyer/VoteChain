import{e as z}from"./eth-query.5602d7fb.js";import{s as O}from"./@metamask.9b2b42ff.js";import{d as W}from"./json-rpc-engine.b866986a.js";import{l as Q}from"./async-mutex.44eb53c5.js";const A=(e,t,s,n)=>function(...o){const i=t.promiseModule;return new i((r,c)=>{t.multiArgs?o.push((...d)=>{t.errorFirst?d[0]?c(d):(d.shift(),r(d)):r(d)}):t.errorFirst?o.push((d,f)=>{d?c(d):r(f)}):o.push(r),Reflect.apply(e,this===s?n:this,o)})},N=new WeakMap;var q=(e,t)=>{t={exclude:[/.+(?:Sync|Stream)$/],errorFirst:!0,promiseModule:Promise,...t};const s=typeof e;if(!(e!==null&&(s==="object"||s==="function")))throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e===null?"null":s}\``);const n=(r,c)=>{let l=N.get(r);if(l||(l={},N.set(r,l)),c in l)return l[c];const d=m=>typeof m=="string"||typeof c=="symbol"?c===m:m.test(c),f=Reflect.getOwnPropertyDescriptor(r,c),y=f===void 0||f.writable||f.configurable,w=(t.include?t.include.some(d):!t.exclude.some(d))&&y;return l[c]=w,w},o=new WeakMap,i=new Proxy(e,{apply(r,c,l){const d=o.get(r);if(d)return Reflect.apply(d,c,l);const f=t.excludeMain?r:A(r,t,i,r);return o.set(r,f),Reflect.apply(f,c,l)},get(r,c){const l=r[c];if(!n(r,c)||l===Function.prototype[c])return l;const d=o.get(l);if(d)return d;if(typeof l=="function"){const f=A(l,t,i,r);return o.set(l,f),f}return l}});return i};const J=O.default;class V extends J{constructor(){super(),this.updates=[]}async initialize(){}async update(){throw new Error("BaseFilter - no update method specified")}addResults(t){this.updates=this.updates.concat(t),t.forEach(s=>this.emit("update",s))}addInitialResults(t){}getChangesAndClear(){const t=this.updates;return this.updates=[],t}}var T=V;const G=T;class K extends G{constructor(){super(),this.allResults=[]}async update(){throw new Error("BaseFilterWithHistory - no update method specified")}addResults(t){this.allResults=this.allResults.concat(t),super.addResults(t)}addInitialResults(t){this.allResults=this.allResults.concat(t),super.addInitialResults(t)}getAllResults(){return this.allResults}}var X=K,B={minBlockRef:Y,maxBlockRef:Z,sortBlockRefs:E,bnToHex:tt,blockRefIsNumber:et,hexToInt:$,incrementHexInt:st,intToHex:D,unsafeRandomBytes:nt};function Y(...e){return E(e)[0]}function Z(...e){const t=E(e);return t[t.length-1]}function E(e){return e.sort((t,s)=>t==="latest"||s==="earliest"?1:s==="latest"||t==="earliest"?-1:$(t)-$(s))}function tt(e){return"0x"+e.toString(16)}function et(e){return e&&!["earliest","latest","pending"].includes(e)}function $(e){return e==null?e:Number.parseInt(e,16)}function st(e){if(e==null)return e;const t=$(e);return D(t+1)}function D(e){if(e==null)return e;let t=e.toString(16);return t.length%2&&(t="0"+t),"0x"+t}function nt(e){let t="0x";for(let s=0;s<e;s++)t+=S(),t+=S();return t}function S(){return Math.floor(Math.random()*16).toString(16)}const rt=z,ot=q,it=X,{bnToHex:Gt,hexToInt:R,incrementHexInt:at,minBlockRef:ct,blockRefIsNumber:lt}=B;class ut extends it{constructor({provider:t,params:s}){super(),this.type="log",this.ethQuery=new rt(t),this.params=Object.assign({fromBlock:"latest",toBlock:"latest",address:void 0,topics:[]},s),this.params.address&&(Array.isArray(this.params.address)||(this.params.address=[this.params.address]),this.params.address=this.params.address.map(n=>n.toLowerCase()))}async initialize({currentBlock:t}){let s=this.params.fromBlock;["latest","pending"].includes(s)&&(s=t),s==="earliest"&&(s="0x0"),this.params.fromBlock=s;const n=ct(this.params.toBlock,t),o=Object.assign({},this.params,{toBlock:n}),i=await this._fetchLogs(o);this.addInitialResults(i)}async update({oldBlock:t,newBlock:s}){const n=s;let o;t?o=at(t):o=s;const i=Object.assign({},this.params,{fromBlock:o,toBlock:n}),c=(await this._fetchLogs(i)).filter(l=>this.matchLog(l));this.addResults(c)}async _fetchLogs(t){return await ot(n=>this.ethQuery.getLogs(t,n))()}matchLog(t){if(R(this.params.fromBlock)>=R(t.blockNumber)||lt(this.params.toBlock)&&R(this.params.toBlock)<=R(t.blockNumber))return!1;const s=t.address&&t.address.toLowerCase();return this.params.address&&s&&!this.params.address.includes(s)?!1:this.params.topics.every((o,i)=>{let r=t.topics[i];if(!r)return!1;r=r.toLowerCase();let c=Array.isArray(o)?o:[o];return c.includes(null)?!0:(c=c.map(f=>f.toLowerCase()),c.includes(r))})}}var dt=ut,C=ft;async function ft({provider:e,fromBlock:t,toBlock:s}){t||(t=s);const n=_(t),i=_(s)-n+1,r=Array(i).fill().map((l,d)=>n+d).map(pt);return await Promise.all(r.map(l=>mt(e,"eth_getBlockByNumber",[l,!1])))}function _(e){return e==null?e:Number.parseInt(e,16)}function pt(e){return e==null?e:"0x"+e.toString(16)}function ht(e,t){return new Promise((s,n)=>{e.sendAsync(t,(o,i)=>{o?n(o):i.error?n(i.error):i.result?s(i.result):n(new Error("Result was empty"))})})}async function mt(e,t,s){for(let n=0;n<3;n++)try{return await ht(e,{id:1,jsonrpc:"2.0",method:t,params:s})}catch(o){console.error(`provider.sendAsync failed: ${o.stack||o.message||o}`)}throw new Error(`Block not found for params: ${JSON.stringify(s)}`)}const yt=T,wt=C,{incrementHexInt:gt}=B;class Ft extends yt{constructor({provider:t,params:s}){super(),this.type="block",this.provider=t}async update({oldBlock:t,newBlock:s}){const n=s,o=gt(t),r=(await wt({provider:this.provider,fromBlock:o,toBlock:n})).map(c=>c.hash);this.addResults(r)}}var bt=Ft;const xt=T,Bt=C,{incrementHexInt:Rt}=B;class Lt extends xt{constructor({provider:t}){super(),this.type="tx",this.provider=t}async update({oldBlock:t}){const s=t,n=Rt(t),o=await Bt({provider:this.provider,fromBlock:n,toBlock:s}),i=[];for(const r of o)i.push(...r.transactions);this.addResults(i)}}var $t=Lt;const Ht=Q.Mutex,{createAsyncMiddleware:It,createScaffoldMiddleware:Mt}=W,kt=dt,vt=bt,Tt=$t,{intToHex:U,hexToInt:k}=B;var Et=Ct;function Ct({blockTracker:e,provider:t}){let s=0,n={};const o=new Ht,i=At({mutex:o}),r=Mt({eth_newFilter:i(v(l)),eth_newBlockFilter:i(v(d)),eth_newPendingTransactionFilter:i(v(f)),eth_uninstallFilter:i(L(w)),eth_getFilterChanges:i(L(y)),eth_getFilterLogs:i(L(g))}),c=async({oldBlock:a,newBlock:u})=>{if(n.length===0)return;const p=await o.acquire();try{await Promise.all(F(n).map(async h=>{try{await h.update({oldBlock:a,newBlock:u})}catch(I){console.error(I)}}))}catch(h){console.error(h)}p()};return r.newLogFilter=l,r.newBlockFilter=d,r.newPendingTransactionFilter=f,r.uninstallFilter=w,r.getFilterChanges=y,r.getFilterLogs=g,r.destroy=()=>{H()},r;async function l(a){const u=new kt({provider:t,params:a});return await m(u),u}async function d(){const a=new vt({provider:t});return await m(a),a}async function f(){const a=new Tt({provider:t});return await m(a),a}async function y(a){const u=k(a),p=n[u];if(!p)throw new Error(`No filter for index "${u}"`);return p.getChangesAndClear()}async function g(a){const u=k(a),p=n[u];if(!p)throw new Error(`No filter for index "${u}"`);let h=[];return p.type==="log"&&(h=p.getAllResults()),h}async function w(a){const u=k(a),p=n[u],h=Boolean(p);return h&&await b(u),h}async function m(a){const u=F(n).length,p=await e.getLatestBlock();await a.initialize({currentBlock:p}),s++,n[s]=a,a.id=s,a.idHex=U(s);const h=F(n).length;return x({prevFilterCount:u,newFilterCount:h}),s}async function b(a){const u=F(n).length;delete n[a];const p=F(n).length;x({prevFilterCount:u,newFilterCount:p})}async function H(){const a=F(n).length;n={},x({prevFilterCount:a,newFilterCount:0})}function x({prevFilterCount:a,newFilterCount:u}){if(a===0&&u>0){e.on("sync",c);return}if(a>0&&u===0){e.removeListener("sync",c);return}}}function v(e){return L(async(...t)=>{const s=await e(...t);return U(s.id)})}function L(e){return It(async(t,s)=>{const n=await e.apply(null,t.params);s.result=n})}function At({mutex:e}){return t=>async(s,n,o,i)=>{(await e.acquire())(),t(s,n,o,i)}}function F(e,t){const s=[];for(let n in e)s.push(e[n]);return s}const Nt=O.default,{createAsyncMiddleware:P,createScaffoldMiddleware:St}=W,_t=Et,{unsafeRandomBytes:Pt,incrementHexInt:Ot}=B,Wt=C;var Kt=Dt;function Dt({blockTracker:e,provider:t}){const s={},n=_t({blockTracker:e,provider:t});let o=!1;const i=new Nt,r=St({eth_subscribe:P(c),eth_unsubscribe:P(l)});return r.destroy=f,{events:i,middleware:r};async function c(y,g){if(o)throw new Error("SubscriptionManager - attempting to use after destroying");const w=y.params[0],m=Pt(16);let b;switch(w){case"newHeads":b=H({subId:m});break;case"logs":const a=y.params[1],u=await n.newLogFilter(a);b=x({subId:m,filter:u});break;default:throw new Error(`SubscriptionManager - unsupported subscription type "${w}"`)}s[m]=b,g.result=m;return;function H({subId:a}){const u={type:w,destroy:async()=>{e.removeListener("sync",u.update)},update:async({oldBlock:p,newBlock:h})=>{const I=h,j=Ot(p);(await Wt({provider:t,fromBlock:j,toBlock:I})).map(Ut).filter(M=>M!==null).forEach(M=>{d(a,M)})}};return e.on("sync",u.update),u}function x({subId:a,filter:u}){return u.on("update",h=>d(a,h)),{type:w,destroy:async()=>await n.uninstallFilter(u.idHex)}}}async function l(y,g){if(o)throw new Error("SubscriptionManager - attempting to use after destroying");const w=y.params[0],m=s[w];if(!m){g.result=!1;return}delete s[w],await m.destroy(),g.result=!0}function d(y,g){i.emit("notification",{jsonrpc:"2.0",method:"eth_subscription",params:{subscription:y,result:g}})}function f(){i.removeAllListeners();for(const y in s)s[y].destroy(),delete s[y];o=!0}}function Ut(e){return e==null?null:{hash:e.hash,parentHash:e.parentHash,sha3Uncles:e.sha3Uncles,miner:e.miner,stateRoot:e.stateRoot,transactionsRoot:e.transactionsRoot,receiptsRoot:e.receiptsRoot,logsBloom:e.logsBloom,difficulty:e.difficulty,number:e.number,gasLimit:e.gasLimit,gasUsed:e.gasUsed,nonce:e.nonce,mixHash:e.mixHash,timestamp:e.timestamp,extraData:e.extraData}}export{Kt as s};
