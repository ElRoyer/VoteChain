import{i as ge}from"./it-parallel-batch.98f352d6.js";import{m as ve}from"./merge-options.8f2a925d.js";import{s as Z}from"./multihashing-async.5e067dad.js";import{r as k}from"./ipfs-unixfs.2c260ee9.js";import{r as ke}from"./cids.77d54c26.js";import{r as z}from"./ipld-dag-pb.39ce16a4.js";import{r as D}from"./err-code.3bb72d65.js";import{r as ze}from"./it-all.77a61972.js";import{i as Ce}from"./it-batch.cd3c5ace.js";import{r as Se}from"./bl.f36d797a.js";import{r as _e}from"./rabin-wasm.d0755ca1.js";import{r as Be}from"./multiformats.98c9d81a.js";import{r as De}from"./hamt-sharding.84502ec0.js";const qe=ve.bind({ignoreUndefined:!0}),Ae=Z;async function Re(d){const a=(await Ae(d,"murmur3-128")).slice(2,10),s=a.length,r=new Uint8Array(s);for(let t=0;t<s;t++)r[s-t-1]=a[t];return r}const Te={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hashAlg:"sha2-256",leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:0x3df305dfb2a804,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,pin:!1,recursive:!1,hidden:!1,preload:!1,timeout:void 0,hamtHashFn:Re,hamtHashCode:34,hamtBucketBits:8};var Ie=function(d={}){return qe(Te,d)},R,X;function _(){if(X)return R;X=1;const d=Z,h=ke();return R=async(s,r,t)=>{t.codec||(t.codec="dag-pb"),t.cidVersion||(t.cidVersion=0),t.hashAlg||(t.hashAlg="sha2-256"),t.hashAlg!=="sha2-256"&&(t.cidVersion=1);const i=await d(s,t.hashAlg),e=new h(t.cidVersion,t.codec,i);return t.onlyHash||await r.put(s,{pin:t.pin,preload:t.preload,timeout:t.timeout,cid:e}),e},R}var T,ee;function Ne(){if(ee)return T;ee=1;const{UnixFS:d}=k(),h=_(),{DAGNode:a}=z();return T=async(r,t,i)=>{const e=new d({type:"directory",mtime:r.mtime,mode:r.mode}),n=new a(e.marshal()).serialize(),u=await h(n,t,i),o=r.path;return{cid:u,path:o,unixfs:e,size:n.length}},T}var I,te;function Ee(){if(te)return I;te=1;const d=ze();return I=async function(h,a){return a(await d(h))},I}var N,re;function Fe(){if(re)return N;re=1;const d=Ce;function h(s,r,t){return a(s,r,t)}async function a(s,r,t){const i=[];for await(const e of d(s,t.maxChildrenPerNode))i.push(await r(e));return i.length>1?a(i,r,t):i[0]}return N=h,N}var E,ie;function Pe(){if(ie)return E;ie=1;const d=Ce;E=async function(r,t,i){const e=new a(i.layerRepeat);let n=0,u=1,o=e;for await(const c of d(r,i.maxChildrenPerNode))o.isFull()&&(o!==e&&e.addChild(await o.reduce(t)),n&&n%i.layerRepeat===0&&u++,o=new h(u,i.layerRepeat,n),n++),o.append(c);return o&&o!==e&&e.addChild(await o.reduce(t)),e.reduce(t)};class h{constructor(r,t,i=0){this.maxDepth=r,this.layerRepeat=t,this.currentDepth=1,this.iteration=i,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:r,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;const r=this._findParent(this.node,this.currentDepth);return r?(this._addNextNodeToParent(r),!1):!0}_addNextNodeToParent(r){this.parent=r;const t={children:[],depth:r.depth+1,parent:r,maxDepth:this.maxDepth,maxChildren:Math.floor(r.children.length/this.layerRepeat)*this.layerRepeat};r.children.push(t),this.currentDepth=t.depth,this.node=t}append(r){this.node.data=r}reduce(r){return this._reduce(this.root,r)}async _reduce(r,t){let i=[];return r.children.length&&(i=await Promise.all(r.children.filter(e=>e.data).map(e=>this._reduce(e,t)))),t((r.data||[]).concat(i))}_findParent(r,t){const i=r.parent;if(!(!i||i.depth===0))return i.children.length===i.maxChildren||!i.maxChildren?this._findParent(i,t):i}}class a extends h{constructor(r){super(0,r),this.root.depth=0,this.currentDepth=1}addChild(r){this.root.children.push(r)}reduce(r){return r((this.root.data||[]).concat(this.root.children))}}return E}var F,ne;function Ve(){if(ne)return F;ne=1;const{UnixFS:d}=k(),h=_(),{DAGNode:a}=z();async function*s(r,t,i){for await(let e of r.content)yield async()=>{i.progress(e.length,r.path);let n;const u={codec:"dag-pb",cidVersion:i.cidVersion,hashAlg:i.hashAlg,onlyHash:i.onlyHash};return i.rawLeaves?(u.codec="raw",u.cidVersion=1):(n=new d({type:i.leafType,data:e,mtime:r.mtime,mode:r.mode}),e=new a(n.marshal()).serialize()),{cid:await h(e,t,u),unixfs:n,size:e.length}}}return F=s,F}var P,ae;function Le(){if(ae)return P;ae=1;const d=D(),{UnixFS:h}=k(),a=_(),{DAGNode:s,DAGLink:r}=z(),t=ge,i=Z.multihash,e={flat:Ee(),balanced:Fe(),trickle:Pe()};async function*n(c,f,y){let p=-1,m,w;typeof y.bufferImporter=="function"?w=y.bufferImporter:w=Ve();for await(const g of t(w(c,f,y),y.blockWriteConcurrency)){if(p++,p===0){m=g;continue}else p===1&&m&&(yield m,m=null);yield g}m&&(m.single=!0,yield m)}const u=(c,f,y)=>{async function p(m){if(m.length===1&&m[0].single&&y.reduceSingleLeafToSelf){const l=m[0];if(l.cid.codec==="raw"&&(c.mtime!==void 0||c.mode!==void 0)){let{data:C}=await f.get(l.cid,y);l.unixfs=new h({type:"file",mtime:c.mtime,mode:c.mode,data:C});const x=i.decode(l.cid.multihash);C=new s(l.unixfs.marshal()).serialize(),l.cid=await a(C,f,{...y,codec:"dag-pb",hashAlg:x.name,cidVersion:y.cidVersion}),l.size=C.length}return{cid:l.cid,path:c.path,unixfs:l.unixfs,size:l.size}}const w=new h({type:"file",mtime:c.mtime,mode:c.mode}),g=m.filter(l=>l.cid.codec==="raw"&&l.size||l.unixfs&&!l.unixfs.data&&l.unixfs.fileSize()?!0:Boolean(l.unixfs&&l.unixfs.data&&l.unixfs.data.length)).map(l=>l.cid.codec==="raw"?(w.addBlockSize(l.size),new r("",l.size,l.cid)):(!l.unixfs||!l.unixfs.data?w.addBlockSize(l.unixfs&&l.unixfs.fileSize()||0):w.addBlockSize(l.unixfs.data.length),new r("",l.size,l.cid))),q=new s(w.marshal(),g),v=q.serialize();return{cid:await a(v,f,y),path:c.path,unixfs:w,size:v.length+q.Links.reduce((l,C)=>l+C.Tsize,0)}}return p};function o(c,f,y){const p=e[y.strategy];if(!p)throw d(new Error(`Unknown importer build strategy name: ${y.strategy}`),"ERR_BAD_STRATEGY");return p(n(c,f,y),u(c,f,y),y)}return P=o,P}var V,se;function $e(){if(se)return V;se=1;const d=Se(),{create:h}=_e(),a=D();V=async function*(t,i){let e,n,u;if(i.minChunkSize&&i.maxChunkSize&&i.avgChunkSize)u=i.avgChunkSize,e=i.minChunkSize,n=i.maxChunkSize;else if(i.avgChunkSize)u=i.avgChunkSize,e=u/3,n=u+u/2;else throw a(new Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");if(e<16)throw a(new Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");n<e&&(n=e),u<e&&(u=e);const o=Math.floor(Math.log2(u));for await(const c of s(t,{min:e,max:n,bits:o,window:i.window,polynomial:i.polynomial}))yield c};async function*s(r,t){const i=await h(t.bits,t.min,t.max,t.window),e=new d;for await(const n of r){e.append(n);const u=i.fingerprint(n);for(let o=0;o<u.length;o++){const c=u[o],f=e.slice(0,c);e.consume(c),yield f}}e.length&&(yield e.slice(0))}return V}var L,ce;function Ue(){if(ce)return L;ce=1;const d=Se();return L=async function*(a,s){let r=new d,t=0,i=!1;const e=s.maxChunkSize;for await(const n of a)for(r.append(n),t+=n.length;t>=e;)if(yield r.slice(0,e),i=!0,e===r.length)r=new d,t=0;else{const u=new d;u.append(r.shallowSlice(e)),r=u,t-=e}(!i||t)&&(yield r.slice(0,t))},L}var $,ue;function He(){if(ue)return $;ue=1;const{bases:d}=Be;function h(t,i,e,n){return{name:t,prefix:i,encoder:{name:t,prefix:i,encode:e},decoder:{decode:n}}}const a=h("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),s=h("ascii","a",t=>{let i="a";for(let e=0;e<t.length;e++)i+=String.fromCharCode(t[e]);return i},t=>{t=t.substring(1);const i=new Uint8Array(t.length);for(let e=0;e<t.length;e++)i[e]=t.charCodeAt(e);return i});return $={utf8:a,"utf-8":a,hex:d.base16,latin1:s,ascii:s,binary:s,...d},$}var U,oe;function Oe(){if(oe)return U;oe=1;const d=He();function h(a,s="utf8"){const r=d[s];if(!r)throw new Error(`Unsupported encoding "${s}"`);return r.decoder.decode(`${r.prefix}${a}`)}return U=h,U}var H,de;function Ge(){if(de)return H;de=1;const d=D(),h=Oe();async function*a(s){for await(const r of s){if(r.length===void 0)throw d(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if(typeof r=="string"||r instanceof String)yield h(r.toString());else if(Array.isArray(r))yield Uint8Array.from(r);else if(r instanceof Uint8Array)yield r;else throw d(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}}return H=a,H}var O,he;function Ke(){if(he)return O;he=1;const d=Ne(),h=Le(),a=D();function s(e){return Symbol.iterator in e}function r(e){return Symbol.asyncIterator in e}function t(e){try{if(e instanceof Uint8Array)return async function*(){yield e}();if(s(e))return async function*(){yield*e}();if(r(e))return e}catch{throw a(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw a(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*i(e,n,u){for await(const o of e)if(o.path&&(o.path.substring(0,2)==="./"&&(u.wrapWithDirectory=!0),o.path=o.path.split("/").filter(c=>c&&c!==".").join("/")),o.content){let c;typeof u.chunker=="function"?c=u.chunker:u.chunker==="rabin"?c=$e():c=Ue();let f;typeof u.chunkValidator=="function"?f=u.chunkValidator:f=Ge();const y={path:o.path,mtime:o.mtime,mode:o.mode,content:c(f(t(o.content),u),u)};yield()=>h(y,n,u)}else if(o.path){const c={path:o.path,mtime:o.mtime,mode:o.mode};yield()=>d(c,n,u)}else throw new Error("Import candidate must have content or path or both")}return O=i,O}var G,le;function J(){if(le)return G;le=1;class d{constructor(a,s){this.options=s||{},this.root=a.root,this.dir=a.dir,this.path=a.path,this.dirty=a.dirty,this.flat=a.flat,this.parent=a.parent,this.parentKey=a.parentKey,this.unixfs=a.unixfs,this.mode=a.mode,this.mtime=a.mtime,this.cid=void 0,this.size=void 0}async put(a,s){}get(a){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(a){}}return G=d,G}var K,fe;function xe(){if(fe)return K;fe=1;const{DAGLink:d,DAGNode:h}=z(),{UnixFS:a}=k(),s=J(),r=_();class t extends s{constructor(e,n){super(e,n),this._children={}}async put(e,n){this.cid=void 0,this.size=void 0,this._children[e]=n}get(e){return Promise.resolve(this._children[e])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async*eachChildSeries(){const e=Object.keys(this._children);for(let n=0;n<e.length;n++){const u=e[n];yield{key:u,child:this._children[u]}}}async*flush(e){const n=Object.keys(this._children),u=[];for(let m=0;m<n.length;m++){let w=this._children[n[m]];if(w instanceof s)for await(const g of w.flush(e))w=g,yield w;w.size!=null&&w.cid&&u.push(new d(n[m],w.size,w.cid))}const o=new a({type:"directory",mtime:this.mtime,mode:this.mode}),c=new h(o.marshal(),u),f=c.serialize(),y=await r(f,e,this.options),p=f.length+c.Links.reduce((m,w)=>m+w.Tsize,0);this.cid=y,this.size=p,yield{cid:y,unixfs:o,path:this.path,size:p}}}return K=t,K}var j,me;function je(){if(me)return j;me=1;const{DAGLink:d,DAGNode:h}=z(),{UnixFS:a}=k(),s=J(),r=_(),{createHAMT:t,Bucket:i}=De();class e extends s{constructor(o,c){super(o,c),this._bucket=t({hashFn:c.hamtHashFn,bits:c.hamtBucketBits})}async put(o,c){await this._bucket.put(o,c)}get(o){return this._bucket.get(o)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:o,value:c}of this._bucket.eachLeafSeries())yield{key:o,child:c}}async*flush(o){for await(const c of n(this._bucket,o,this,this.options))yield{...c,path:this.path}}}j=e;async function*n(u,o,c,f){const y=u._children,p=[];let m=0;for(let C=0;C<y.length;C++){const x=y.get(C);if(!x)continue;const A=C.toString(16).toUpperCase().padStart(2,"0");if(x instanceof i){let S;for await(const b of await n(x,o,null,f))S=b;if(!S)throw new Error("Could not flush sharded directory, no subshard found");p.push(new d(A,S.size,S.cid)),m+=S.size}else if(typeof x.value.flush=="function"){const S=x.value;let b;for await(const be of S.flush(o))b=be,yield b;const B=A+x.key;p.push(new d(B,b.size,b.cid)),m+=b.size}else{const S=x.value;if(!S.cid)continue;const b=A+x.key,B=S.size;p.push(new d(b,B,S.cid)),m+=B}}const w=Uint8Array.from(y.bitField().reverse()),g=new a({type:"hamt-sharded-directory",data:w,fanout:u.tableSize(),hashType:f.hamtHashCode,mtime:c&&c.mtime,mode:c&&c.mode}),v=new h(g.marshal(),p).serialize(),Q=await r(v,o,f),l=v.length+m;yield{cid:Q,unixfs:g,size:l}}return j}var M,ye;function Me(){if(ye)return M;ye=1;const d=je(),h=xe();M=async function s(r,t,i,e){let n=t;t instanceof h&&t.directChildrenCount()>=i&&(n=await a(t,e));const u=n.parent;if(u){if(n!==t){if(r&&(r.parent=n),!n.parentKey)throw new Error("No parent key found");await u.put(n.parentKey,n)}return s(n,u,i,e)}return n};async function a(s,r){const t=new d({root:s.root,dir:!0,parent:s.parent,parentKey:s.parentKey,path:s.path,dirty:s.dirty,flat:!1,mtime:s.mtime,mode:s.mode},r);for await(const{key:i,child:e}of s.eachChildSeries())await t.put(i,e);return t}return M}var W,we;function We(){return we||(we=1,W=(h="")=>(h.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)),W}var Y,pe;function Ye(){if(pe)return Y;pe=1;const d=xe(),h=Me(),a=J(),s=We();async function r(e,n,u){const o=s(e.path||""),c=o.length-1;let f=n,y="";for(let p=0;p<o.length;p++){const m=o[p];y+=`${y?"/":""}${m}`;const w=p===c;if(f.dirty=!0,f.cid=void 0,f.size=void 0,w)await f.put(m,e),n=await h(null,f,u.shardSplitThreshold,u);else{let g=await f.get(m);(!g||!(g instanceof a))&&(g=new d({root:!1,dir:!0,parent:f,parentKey:m,path:y,dirty:!0,flat:!0,mtime:g&&g.unixfs&&g.unixfs.mtime,mode:g&&g.unixfs&&g.unixfs.mode},u)),await f.put(m,g),f=g}}return n}async function*t(e,n){if(!(e instanceof a)){e&&e.unixfs&&e.unixfs.isDirectory()&&(yield e);return}yield*e.flush(n)}async function*i(e,n,u){let o=new d({root:!0,dir:!0,path:"",dirty:!0,flat:!0},u);for await(const c of e)!c||(o=await r(c,o,u),(!c.unixfs||!c.unixfs.isDirectory())&&(yield c));if(u.wrapWithDirectory)yield*t(o,n);else for await(const c of o.eachChildSeries())!c||(yield*t(c.child,n))}return Y=i,Y}const Ze=ge,Je=Ie;async function*Qe(d,h,a={}){const s=Je(a);let r;typeof a.dagBuilder=="function"?r=a.dagBuilder:r=Ke();let t;typeof a.treeBuilder=="function"?t=a.treeBuilder:t=Ye();let i;Symbol.asyncIterator in d||Symbol.iterator in d?i=d:i=[d];for await(const e of t(Ze(r(i,h,s),s.fileImportConcurrency),h,s))yield{cid:e.cid,path:e.path,unixfs:e.unixfs,size:e.size}}var lt={importer:Qe};export{lt as s};
